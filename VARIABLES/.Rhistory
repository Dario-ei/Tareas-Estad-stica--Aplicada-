theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5))
# Calcular cuantiles importantes
percentiles <- c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99)
# Para diferentes distribuciones normales
configuraciones_cuant <- list(
"N(0, 1)" = list(mu = 0, sigma = 1),
"N(100, 15)" = list(mu = 100, sigma = 15),
"N(-5, 2)" = list(mu = -5, sigma = 2)
)
# Crear tabla de cuantiles
tabla_cuantiles <- data.frame(
Percentil = paste0(percentiles * 100, "%"),
`Z crítico` = round(qnorm(percentiles), 3)
)
for (nombre in names(configuraciones_cuant)) {
config <- configuraciones_cuant[[nombre]]
cuantiles <- qnorm(percentiles, mean = config$mu, sd = config$sigma)
tabla_cuantiles[[nombre]] <- round(cuantiles, 2)
}
kable(tabla_cuantiles,
caption = "Cuantiles para diferentes distribuciones normales") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
scroll_box(width = "100%")
# Valores críticos comunes
valores_criticos <- data.frame(
`Nombre` = c("1.96", "2.58", "1.64", "1.28", "2.33"),
`Valor Z` = c(1.96, 2.58, 1.645, 1.282, 2.326),
`Probabilidad` = c(0.975, 0.995, 0.95, 0.90, 0.99),
`Intervalo Central` = c("95%", "99%", "90%", "80%", "98%"),
`Uso Común` = c(
"IC 95%, pruebas bilaterales",
"IC 99%, pruebas bilaterales",
"Pruebas unilaterales α = 0.05",
"Pruebas unilaterales α = 0.10",
"Pruebas unilaterales α = 0.01"
),
check.names = FALSE
)
kable(valores_criticos,
caption = "Valores críticos importantes de la distribución normal estándar") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# Mostrar cuantiles en el gráfico de CDF
mu_q <- 10
sigma_q <- 3
x_q <- seq(mu_q - 4*sigma_q, mu_q + 4*sigma_q, length.out = 1000)
cdf_q <- pnorm(x_q, mean = mu_q, sd = sigma_q)
# Cuantiles específicos
p_vals <- c(0.25, 0.5, 0.75)
q_vals <- qnorm(p_vals, mean = mu_q, sd = sigma_q)
# Crear puntos para los cuantiles
df_cuantiles <- data.frame(
x = q_vals,
y = p_vals,
etiqueta = paste0("Q", p_vals*100, " = ", round(q_vals, 1))
)
ggplot(data.frame(x = x_q, y = cdf_q), aes(x = x, y = y)) +
geom_line(linewidth = 1.5, color = "blue") +
geom_hline(yintercept = p_vals, linetype = "dashed", color = "red", alpha = 0.7) +
geom_vline(xintercept = q_vals, linetype = "dashed", color = "red", alpha = 0.7) +
geom_point(data = df_cuantiles, aes(x = x, y = y),
color = "red", size = 3) +
geom_label(data = df_cuantiles, aes(x = x, y = y, label = etiqueta),
vjust = -0.5, hjust = 0.5, size = 3.5) +
labs(title = paste("Cuantiles en la CDF: N(", mu_q, ",", sigma_q, ")"),
x = "x", y = "F(x)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5)) +
ylim(0, 1)
# Verificar propiedades de simetría
z_simetria <- c(0.5, 1, 1.5, 2, 2.5, 3)
verificacion_simetria <- data.frame(
z = z_simetria,
`Φ(z)` = round(pnorm(z_simetria), 4),
`Φ(-z)` = round(pnorm(-z_simetria), 4),
`1 - Φ(z)` = round(1 - pnorm(z_simetria), 4),
`P(-z < Z < z)` = round(2*pnorm(z_simetria) - 1, 4),
`Verificación` = round(pnorm(-z_simetria), 4) == round(1 - pnorm(z_simetria), 4),
check.names = FALSE
)
kable(verificacion_simetria,
caption = "Verificación de propiedades de simetría") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# Visualizar la simetría
z_sym <- seq(-3, 3, length.out = 1000)
phi_sym <- dnorm(z_sym)
cdf_sym <- pnorm(z_sym)
# Punto específico para mostrar simetría
z_punto <- 1.5
punto_neg <- -z_punto
cdf_pos <- pnorm(z_punto)
cdf_neg <- pnorm(punto_neg)
ggplot(data.frame(z = z_sym, phi = phi_sym, cdf = cdf_sym)) +
geom_line(aes(x = z, y = phi), linewidth = 1.2, color = "blue") +
geom_area(data = data.frame(z = z_sym[z_sym <= punto_neg],
phi = phi_sym[z_sym <= punto_neg]),
aes(x = z, y = phi), fill = "red", alpha = 0.3) +
geom_area(data = data.frame(z = z_sym[z_sym >= z_punto],
phi = phi_sym[z_sym >= z_punto]),
aes(x = z, y = phi), fill = "red", alpha = 0.3) +
geom_vline(xintercept = c(punto_neg, z_punto), linetype = "dashed", color = "red") +
annotate("text", x = punto_neg, y = 0.3,
label = paste("Φ(", punto_neg, ") =", round(cdf_neg, 3)),
angle = 90, vjust = -0.5, size = 3.5) +
annotate("text", x = z_punto, y = 0.3,
label = paste("1 - Φ(", z_punto, ") =", round(1 - cdf_pos, 3)),
angle = 90, vjust = 1.5, size = 3.5) +
labs(title = "Propiedad de Simetría: Φ(-z) = 1 - Φ(z)",
subtitle = "Las áreas sombreadas son iguales",
x = "z", y = "φ(z)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5))
# Parámetros de la distribución normal
mu_sim <- 75
sigma_sim <- 12
# Parámetros teóricos
media_teorica <- mu_sim
varianza_teorica <- sigma_sim^2
desv_std_teorica <- sigma_sim
mediana_teorica <- mu_sim  # Por simetría
moda_teorica <- mu_sim     # Unimodal en μ
cat("Distribución: N(μ =", mu_sim, ", σ² =", varianza_teorica, ")\n")
cat("Media teórica:", media_teorica, "\n")
cat("Mediana teórica:", mediana_teorica, "\n")
cat("Moda teórica:", moda_teorica, "\n")
cat("Varianza teórica:", varianza_teorica, "\n")
cat("Desviación estándar teórica:", desv_std_teorica, "\n")
cat("Coeficiente de variación teórico:", round(desv_std_teorica/media_teorica, 4), "\n")
# Diferentes tamaños de muestra
tamaños_muestra <- c(30, 100, 500, 1000, 5000, 10000)
# Función para calcular estadísticos muestrales
calcular_estadisticos_normal <- function(n, mu, sigma) {
muestra <- rnorm(n, mean = mu, sd = sigma)
return(data.frame(
n = n,
media_muestral = mean(muestra),
varianza_muestral = var(muestra),
desv_std_muestral = sd(muestra),
mediana_muestral = median(muestra),
min_muestral = min(muestra),
max_muestral = max(muestra),
q1_muestral = quantile(muestra, 0.25),
q3_muestral = quantile(muestra, 0.75)
))
}
# Realizar simulaciones
resultados_simulacion <- do.call(rbind, lapply(tamaños_muestra, calcular_estadisticos_normal,
mu = mu_sim, sigma = sigma_sim))
# Agregar valores teóricos y errores
resultados_simulacion$media_teorica <- media_teorica
resultados_simulacion$varianza_teorica <- varianza_teorica
resultados_simulacion$desv_std_teorica <- desv_std_teorica
resultados_simulacion$mediana_teorica <- mediana_teorica
resultados_simulacion$asimetria_teorica <- 0
resultados_simulacion$curtosis_teorica <- 3
# Calcular errores relativos
resultados_simulacion$error_media <- abs(resultados_simulacion$media_muestral - media_teorica) / media_teorica * 100
resultados_simulacion$error_varianza <- abs(resultados_simulacion$varianza_muestral - varianza_teorica) / varianza_teorica * 100
resultados_simulacion$error_desv_std <- abs(resultados_simulacion$desv_std_muestral - desv_std_teorica) / desv_std_teorica * 100
# Mostrar tabla de resultados principales
tabla_principales <- resultados_simulacion[, c("n", "media_muestral", "media_teorica", "error_media",
"varianza_muestral", "varianza_teorica", "error_varianza",
"desv_std_muestral", "desv_std_teorica", "error_desv_std")]
kable(tabla_principales,
caption = "Convergencia de estadísticos muestrales hacia valores teóricos",
digits = 3,
col.names = c("n", "Media Obs.", "Media Teór.", "Error %",
"Var. Obs.", "Var. Teór.", "Error %",
"DE Obs.", "DE Teór.", "Error %")) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
#| warning: false
# Generar una secuencia larga para observar convergencia
n_total <- 15000
muestra_larga <- rnorm(n_total, mean = mu_sim, sd = sigma_sim)
# Calcular estadísticos acumulados
indices <- 1:n_total
medias_acumuladas <- cumsum(muestra_larga) / indices
varianzas_acumuladas <- sapply(indices, function(i) var(muestra_larga[1:i]))
desv_std_acumuladas <- sqrt(varianzas_acumuladas)
# Crear dataframe para gráficos
df_convergencia <- data.frame(
n = indices,
media_acumulada = medias_acumuladas,
varianza_acumulada = varianzas_acumuladas,
desv_std_acumulada = desv_std_acumuladas
)
# Gráfico de convergencia de la media
p1 <- ggplot(df_convergencia, aes(x = n)) +
geom_line(aes(y = media_acumulada), color = "blue", alpha = 0.8) +
geom_hline(yintercept = media_teorica, color = "red", linetype = "dashed", linewidth = 1) +
labs(title = "Convergencia de la Media Muestral",
x = "Tamaño de muestra (n)",
y = "Media acumulada",
caption = paste("Línea roja: Media teórica =", media_teorica)) +
theme_minimal() +
ylim(media_teorica - 2, media_teorica + 2)
# Gráfico de convergencia de la desviación estándar
p2 <- ggplot(df_convergencia, aes(x = n)) +
geom_line(aes(y = desv_std_acumulada), color = "green", alpha = 0.8) +
geom_hline(yintercept = desv_std_teorica, color = "red", linetype = "dashed", linewidth = 1) +
labs(title = "Convergencia de la Desviación Estándar",
x = "Tamaño de muestra (n)",
y = "Desviación estándar acumulada",
caption = paste("Línea roja: DE teórica =", desv_std_teorica)) +
theme_minimal() +
ylim(desv_std_teorica - 2, desv_std_teorica + 2)
# Mostrar ambos gráficos
grid.arrange(p1, p2, ncol = 2,
top = "Ley de Grandes Números - Distribución Normal")
# Generar muestra grande para comparación visual
muestra_grande <- rnorm(10000, mean = mu_sim, sd = sigma_sim)
# Crear histograma con densidad teórica superpuesta
ggplot(data.frame(x = muestra_grande), aes(x = x)) +
geom_histogram(aes(y = after_stat(density)), bins = 50,
fill = "lightblue", color = "black", alpha = 0.7) +
stat_function(fun = dnorm, args = list(mean = mu_sim, sd = sigma_sim),
color = "red", linewidth = 2) +
geom_vline(xintercept = media_teorica, color = "red", linetype = "dashed", linewidth = 1) +
geom_vline(xintercept = c(mu_sim - sigma_sim, mu_sim + sigma_sim),
color = "orange", linetype = "dotted", linewidth = 1) +
labs(title = "Histograma de Muestra vs Densidad Teórica",
subtitle = paste("10,000 observaciones de N(", mu_sim, ",", sigma_sim, "²)"),
x = "Valores",
y = "Densidad",
caption = "Curva roja: Densidad teórica | Línea roja: μ | Líneas naranjas: μ ± σ") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5))
# Verificar la regla 68-95-99.7 con la muestra simulada
n_muestra_regla <- 10000
muestra_regla <- rnorm(n_muestra_regla, mean = mu_sim, sd = sigma_sim)
# Intervalos teóricos
intervalo_1sigma <- c(mu_sim - sigma_sim, mu_sim + sigma_sim)
intervalo_2sigma <- c(mu_sim - 2*sigma_sim, mu_sim + 2*sigma_sim)
intervalo_3sigma <- c(mu_sim - 3*sigma_sim, mu_sim + 3*sigma_sim)
# Proporciones observadas
prop_1sigma_obs <- mean(muestra_regla >= intervalo_1sigma[1] & muestra_regla <= intervalo_1sigma[2])
prop_2sigma_obs <- mean(muestra_regla >= intervalo_2sigma[1] & muestra_regla <= intervalo_2sigma[2])
prop_3sigma_obs <- mean(muestra_regla >= intervalo_3sigma[1] & muestra_regla <= intervalo_3sigma[2])
# Proporciones teóricas
prop_1sigma_teo <- pnorm(1) - pnorm(-1)
prop_2sigma_teo <- pnorm(2) - pnorm(-2)
prop_3sigma_teo <- pnorm(3) - pnorm(-3)
# Crear tabla de verificación
verificacion_regla <- data.frame(
Intervalo = c("μ ± 1σ", "μ ± 2σ", "μ ± 3σ"),
`Rango Numérico` = c(
paste("[", round(intervalo_1sigma[1], 1), ",", round(intervalo_1sigma[2], 1), "]"),
paste("[", round(intervalo_2sigma[1], 1), ",", round(intervalo_2sigma[2], 1), "]"),
paste("[", round(intervalo_3sigma[1], 1), ",", round(intervalo_3sigma[2], 1), "]")
),
`Proporción Teórica` = c(prop_1sigma_teo, prop_2sigma_teo, prop_3sigma_teo),
`Porcentaje Teórico` = c("68.27%", "95.45%", "99.73%"),
`Proporción Observada` = c(prop_1sigma_obs, prop_2sigma_obs, prop_3sigma_obs),
`Porcentaje Observado` = paste0(round(c(prop_1sigma_obs, prop_2sigma_obs, prop_3sigma_obs) * 100, 2), "%"),
`Error Absoluto` = abs(c(prop_1sigma_obs, prop_2sigma_obs, prop_3sigma_obs) -
c(prop_1sigma_teo, prop_2sigma_teo, prop_3sigma_teo)),
check.names = FALSE
)
kable(verificacion_regla,
caption = paste("Verificación de la regla empírica con", n_muestra_regla, "observaciones"),
digits = 4) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# Parámetros del proceso
mu_tornillos <- 8.00  # mm
sigma_tornillos <- 0.15  # mm
limite_inferior <- 7.70
limite_superior <- 8.30
# Simulación de un lote de producción
n_lote <- 5000
set.seed(456)
diametros <- rnorm(n_lote, mean = mu_tornillos, sd = sigma_tornillos)
# Análisis de calidad
dentro_especificacion <- sum(diametros >= limite_inferior & diametros <= limite_superior)
defectos_pequeños <- sum(diametros < limite_inferior)
defectos_grandes <- sum(diametros > limite_superior)
porcentaje_calidad <- (dentro_especificacion / n_lote) * 100
porcentaje_def_pequeños <- (defectos_pequeños / n_lote) * 100
porcentaje_def_grandes <- (defectos_grandes / n_lote) * 100
# Cálculos teóricos
prob_calidad_teorica <- pnorm(limite_superior, mu_tornillos, sigma_tornillos) -
pnorm(limite_inferior, mu_tornillos, sigma_tornillos)
prob_def_pequeños_teorica <- pnorm(limite_inferior, mu_tornillos, sigma_tornillos)
prob_def_grandes_teorica <- 1 - pnorm(limite_superior, mu_tornillos, sigma_tornillos)
cat("=== ANÁLISIS DE CONTROL DE CALIDAD ===\n")
cat("Proceso: Diámetro ~ N(8.00, 0.15²) mm\n")
cat("Especificación: [7.70, 8.30] mm\n")
cat("Lote simulado:", n_lote, "tornillos\n\n")
cat("RESULTADOS DE CALIDAD:\n")
cat("• Tornillos dentro de especificación:", dentro_especificacion, "(", round(porcentaje_calidad, 2), "%)\n")
cat("• Defectos por tamaño pequeño:", defectos_pequeños, "(", round(porcentaje_def_pequeños, 2), "%)\n")
cat("• Defectos por tamaño grande:", defectos_grandes, "(", round(porcentaje_def_grandes, 2), "%)\n\n")
cat("COMPARACIÓN CON VALORES TEÓRICOS:\n")
cat("• Calidad teórica:", round(prob_calidad_teorica * 100, 2), "%\n")
cat("• Defectos pequeños teórico:", round(prob_def_pequeños_teorica * 100, 2), "%\n")
cat("• Defectos grandes teórico:", round(prob_def_grandes_teorica * 100, 2), "%\n")
# Visualización
ggplot(data.frame(diametro = diametros), aes(x = diametro)) +
geom_histogram(aes(y = after_stat(density)), bins = 50,
fill = "lightblue", color = "black", alpha = 0.7) +
stat_function(fun = dnorm, args = list(mean = mu_tornillos, sd = sigma_tornillos),
color = "red", linewidth = 2) +
geom_vline(xintercept = c(limite_inferior, limite_superior),
color = "darkgreen", linewidth = 2, linetype = "dashed") +
geom_vline(xintercept = mu_tornillos, color = "red", linewidth = 1, linetype = "dotted") +
annotate("rect", xmin = limite_inferior, xmax = limite_superior,
ymin = 0, ymax = Inf, alpha = 0.1, fill = "green") +
labs(title = "Control de Calidad: Diámetro de Tornillos",
subtitle = "Zona verde: Especificación aceptable",
x = "Diámetro (mm)",
y = "Densidad") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5))
#| warning: false
# Parámetros del sistema
mu_sistema <- 2.5  # segundos
sigma_sistema <- 0.8  # segundos
# Simular tiempos de respuesta durante diferentes períodos
n_solicitudes <- 3000
set.seed(101112)
tiempos_respuesta <- rnorm(n_solicitudes, mean = mu_sistema, sd = sigma_sistema)
# Filtrar tiempos negativos (no físicamente posibles)
tiempos_respuesta <- tiempos_respuesta[tiempos_respuesta > 0]
n_validos <- length(tiempos_respuesta)
# Análisis de SLA (Service Level Agreement)
sla_excelente <- 1.5  # < 1.5 seg
sla_bueno <- 3.0      # < 3.0 seg
sla_aceptable <- 4.5  # < 4.5 seg
sla_inaceptable <- 6.0 # ≥ 6.0 seg
# Calcular cumplimiento de SLA
cumple_excelente <- mean(tiempos_respuesta < sla_excelente) * 100
cumple_bueno <- mean(tiempos_respuesta < sla_bueno) * 100
cumple_aceptable <- mean(tiempos_respuesta < sla_aceptable) * 100
sobre_inaceptable <- mean(tiempos_respuesta >= sla_inaceptable) * 100
# Cálculos teóricos
cum_excelente_teo <- pnorm(sla_excelente, mu_sistema, sigma_sistema) * 100
cum_bueno_teo <- pnorm(sla_bueno, mu_sistema, sigma_sistema) * 100
cum_aceptable_teo <- pnorm(sla_aceptable, mu_sistema, sigma_sistema) * 100
sobre_inaceptable_teo <- (1 - pnorm(sla_inaceptable, mu_sistema, sigma_sistema)) * 100
cat("Distribución: Tiempo ~ N(2.5, 0.8²) segundos\n")
cat("Solicitudes analizadas:", n_validos, "\n\n")
cat("CUMPLIMIENTO DE SLA:\n")
cat("• Excelente (< 1.5s): ", round(cumple_excelente, 1), "% (Teórico: ", round(cum_excelente_teo, 1), "%)\n")
cat("• Bueno (< 3.0s): ", round(cumple_bueno, 1), "% (Teórico: ", round(cum_bueno_teo, 1), "%)\n")
cat("• Aceptable (< 4.5s): ", round(cumple_aceptable, 1), "% (Teórico: ", round(cum_aceptable_teo, 1), "%)\n")
cat("• Inaceptable (≥ 6.0s): ", round(sobre_inaceptable, 1), "% (Teórico: ", round(sobre_inaceptable_teo, 1), "%)\n\n")
# Estadísticos del sistema
media_observada <- mean(tiempos_respuesta)
mediana_observada <- median(tiempos_respuesta)
p95_observado <- quantile(tiempos_respuesta, 0.95)
p99_observado <- quantile(tiempos_respuesta, 0.99)
# Teóricos
p95_teorico <- qnorm(0.95, mu_sistema, sigma_sistema)
p99_teorico <- qnorm(0.99, mu_sistema, sigma_sistema)
cat("MÉTRICAS DE RENDIMIENTO:\n")
cat("• Tiempo promedio: ", round(media_observada, 3), "s (Teórico: ", mu_sistema, "s)\n")
cat("• Tiempo mediano: ", round(mediana_observada, 3), "s (Teórico: ", mu_sistema, "s)\n")
cat("• Percentil 95: ", round(p95_observado, 3), "s (Teórico: ", round(p95_teorico, 3), "s)\n")
cat("• Percentil 99: ", round(p99_observado, 3), "s (Teórico: ", round(p99_teorico, 3), "s)\n")
# Análisis de capacidad del sistema
# ¿Qué porcentaje del tiempo el sistema responde en menos de 2 segundos?
objetivo_2s <- pnorm(2, mu_sistema, sigma_sistema) * 100
objetivo_2s_obs <- mean(tiempos_respuesta < 2) * 100
cat("\nANÁLISIS DE CAPACIDAD:\n")
cat("• Respuestas < 2s: ", round(objetivo_2s_obs, 1), "% (Teórico: ", round(objetivo_2s, 1), "%)\n")
# Mejora del sistema: ¿Qué pasa si reducimos σ a 0.6?
sigma_mejorado <- 0.6
mejora_bueno <- pnorm(sla_bueno, mu_sistema, sigma_mejorado) * 100
mejora_excelente <- pnorm(sla_excelente, mu_sistema, sigma_mejorado) * 100
cat("• Con mejora (σ = 0.6): Bueno ", round(mejora_bueno, 1), "%, Excelente ", round(mejora_excelente, 1), "%\n")
# Visualización
ggplot(data.frame(tiempo = tiempos_respuesta), aes(x = tiempo)) +
geom_histogram(aes(y = after_stat(density)), bins = 50,
fill = "lightgreen", color = "black", alpha = 0.7) +
stat_function(fun = dnorm, args = list(mean = mu_sistema, sd = sigma_sistema),
color = "darkgreen", linewidth = 2) +
geom_vline(xintercept = c(sla_excelente, sla_bueno, sla_aceptable, sla_inaceptable),
color = c("green", "orange", "red", "darkred"),
linewidth = c(2, 2, 2, 2), linetype = "dashed") +
geom_vline(xintercept = mu_sistema, color = "blue", linewidth = 2) +
annotate("text", x = sla_excelente, y = 0.4, label = "Excelente\n< 1.5s",
color = "green", size = 3, angle = 90, vjust = -0.5) +
annotate("text", x = sla_bueno, y = 0.35, label = "Bueno\n< 3.0s",
color = "orange", size = 3, angle = 90, vjust = -0.5) +
annotate("text", x = sla_aceptable, y = 0.3, label = "Aceptable\n< 4.5s",
color = "red", size = 3, angle = 90, vjust = -0.5) +
labs(title = "Análisis de Tiempos de Respuesta del Sistema",
subtitle = "Líneas verticales indican niveles de SLA",
x = "Tiempo de respuesta (segundos)",
y = "Densidad") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5)) +
xlim(0, 7)
mu_altura <- 170
sigma_altura <- 8
mu_altura <- rnorm(500,  mean = mu_altura, sd = 8)
media_altura  <- mean(muestra_altura)
mediana_altura <- median(muestra_altura)
sd_altura <- sd(muestra_altura)
cat("La media de la altura es:", media_altura, "/n")
cat("La mediana de la altura es:", mediana_altura, "/n")
cat("La sd de la altura es:", sd_altura, "/n")
set.seed(123)
mu_altura <- 170
sigma_altura <- 8
mu_altura <- rnorm(500,  mean = mu_altura, sd = 8)
media_altura  <- mean(muestra_altura)
mediana_altura <- median(muestra_altura)
sd_altura <- sd(muestra_altura)
cat("La media de la altura es:", media_altura, "/n")
cat("La mediana de la altura es:", mediana_altura, "/n")
cat("La sd de la altura es:", sd_altura, "/n")
set.seed(123)
muestra_altura <- rnorm(400, mean = 170, sd = 10) # 400 observaciones
mu_altura <- mean(muestra_altura)
sigma_altura <- sd(muestra_altura)
mu_altura <- rnorm(500,  mean = mu_altura, sd = 8)
media_altura  <- mean(muestra_altura)
mediana_altura <- median(muestra_altura)
sd_altura <- sd(muestra_altura)
cat("La media de la altura es:", media_altura, "/n")
cat("La mediana de la altura es:", mediana_altura, "/n")
cat("La sd de la altura es:", sd_altura, "/n")
#| include: false
#| label: setup
library(ggplot2)
library(dplyr)
library(knitr)
library(kableExtra)
library(plotly)
set.seed(123)
n <- 1000
a <- 2
b <- 8
# Simulación
tiempos <- runif(n, min=a, max=b)
# 1. Histograma con densidad
hist(tiempos, breaks=30, probability=TRUE, col="lightblue",
main="Histograma de tiempos de carga con densidad teórica",
xlab="Tiempo de carga (s)")
curve(dunif(x, min=a, max=b), add=TRUE, col="red", lwd=2)
# 2. Percentil 75
percentil75 <- quantile(tiempos, 0.75)
percentil75_teo <- qunif(0.75, min=a, max=b)
cat("Percentil 75 (simulación):", percentil75, "\n")
cat("Percentil 75 (teórico):", percentil75_teo, "\n\n")
# 3. Probabilidad de cargar en menos de 4 segundos
prob_menor4 <- punif(4, min=a, max=b)
cat("Probabilidad de cargar en menos de 4 segundos:", prob_menor4, "\n")
set.seed(123)
n <- 500
min_score <- 70
max_score <- 100
# 1. Simulación
calificaciones <- runif(n, min=min_score, max=max_score)
# 2. Porcentaje > 85
porcentaje_mayor85 <- mean(calificaciones > 85) * 100
cat("Porcentaje de estudiantes con calificación > 85:", porcentaje_mayor85, "%\n")
# 3. Categorías
categorias <- cut(calificaciones,
breaks=c(70,80,90,100),
labels=c("Aprobado","Bien","Excelente"),
right=FALSE)
# Porcentaje simulados
tabla_sim <- prop.table(table(categorias)) * 100
cat("\nPorcentajes simulados por categoría:\n")
print(tabla_sim)
# Porcentajes teóricos
tabla_teo <- c(33.3, 33.3, 33.3)
names(tabla_teo) <- c("Aprobado","Bien","Excelente")
cat("\nPorcentajes teóricos por categoría:\n")
# Librerías
library(e1071)
set.seed(123)
# 1. Generar población uniforme truncada
n_total <- 100000
x <- runif(n_total, 0, 1)
x_trunc <- x[x > 0.3]
# 2. Verificación del TCL
n_sim <- 800
n_vals <- c(5, 15, 30, 60, 120)
par(mfrow=c(3,2))
for(n in n_vals){
medias <- replicate(n_sim, mean(sample(x_trunc, n, replace=TRUE)))
media_pob <- mean(x_trunc)
sd_pob <- sd(x_trunc)
medias_norm <- (medias - media_pob) / (sd_pob/sqrt(n))
hist(medias_norm, probability=TRUE, breaks=20,
main=paste("n =", n, "medias muestrales"),
xlab="Medias normalizadas", col="lightblue")
curve(dnorm(x), add=TRUE, col="red", lwd=2)
skew <- skewness(medias_norm)
kurt <- kurtosis(medias_norm)
cat("n =", n, "Skewness =", round(skew,3), "Kurtosis =", round(kurt,3), "\n")
}
set.seed(123)
# Número de simulaciones
n_sim <- 100000
# 1. Generar puntos uniformes
x <- runif(n_sim, 0, 1)
y <- runif(n_sim, 0, 1)
# 2. Contar puntos dentro del cuadrante
dentro <- x^2 + y^2 <= 1
pi_est <- 4 * mean(dentro)
cat("Estimación de pi usando Monte Carlo:", pi_est, "\n")
# 3. Visualización
plot(x, y, col=ifelse(dentro, "blue", "red"), pch=16, cex=0.5,
xlab="x", ylab="y", main=paste("Estimación de pi =", round(pi_est, 5)))
symbols(0, 0, circles=1, add=TRUE, inches=FALSE, lwd=2)
